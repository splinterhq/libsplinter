/* automatically generated by rust-bindgen 0.72.1 */

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 36;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const __alignas_is_defined: u32 = 1;
pub const __alignof_is_defined: u32 = 1;
pub const SPLINTER_MAGIC: u32 = 1397509716;
pub const SPLINTER_VER: u32 = 2;
pub const SPLINTER_KEY_MAX: u32 = 64;
pub const NS_PER_MS: u32 = 1000000;
pub const SPLINTER_MAX_GROUPS: u32 = 64;
pub const SPL_SYS_AUTO_SCRUB: u32 = 1;
pub const SPL_SYS_HYBRID_SCRUB: u32 = 2;
pub const SPL_SYS_RESERVED_2: u32 = 4;
pub const SPL_SYS_RESERVED_3: u32 = 8;
pub const SPL_SUSR1: u32 = 16;
pub const SPL_SUSR2: u32 = 32;
pub const SPL_SUSR3: u32 = 64;
pub const SPL_SUSR4: u32 = 128;
pub const SPL_SLOT_TYPE_VOID: u32 = 1;
pub const SPL_SLOT_TYPE_BIGINT: u32 = 2;
pub const SPL_SLOT_TYPE_BIGUINT: u32 = 4;
pub const SPL_SLOT_TYPE_JSON: u32 = 8;
pub const SPL_SLOT_TYPE_BINARY: u32 = 16;
pub const SPL_SLOT_TYPE_IMGDATA: u32 = 32;
pub const SPL_SLOT_TYPE_AUDIO: u32 = 64;
pub const SPL_SLOT_TYPE_VARTEXT: u32 = 128;
pub const SPL_SLOT_DEFAULT_TYPE: u32 = 1;
pub const SPL_FUSR1: u32 = 1;
pub const SPL_FUSR2: u32 = 2;
pub const SPL_FUSR3: u32 = 4;
pub const SPL_FUSR4: u32 = 8;
pub const SPL_FUSR5: u32 = 16;
pub const SPL_FUSR6: u32 = 32;
pub const SPL_FUSR7: u32 = 64;
pub const SPL_FUSR8: u32 = 128;
pub const SPL_TIME_CTIME: u32 = 0;
pub const SPL_TIME_ATIME: u32 = 1;
pub const SPL_ORDER_ACCESSOR: &[u8; 2] = b".\0";
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of max_align_t"][::std::mem::size_of::<max_align_t>() - 32usize];
    ["Alignment of max_align_t"][::std::mem::align_of::<max_align_t>() - 16usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce1"]
        [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce1) - 0usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce2"]
        [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce2) - 16usize];
};
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __fsid_t"][::std::mem::size_of::<__fsid_t>() - 8usize];
    ["Alignment of __fsid_t"][::std::mem::align_of::<__fsid_t>() - 4usize];
    ["Offset of field: __fsid_t::__val"][::std::mem::offset_of!(__fsid_t, __val) - 0usize];
};
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub const memory_order_memory_order_relaxed: memory_order = 0;
pub const memory_order_memory_order_consume: memory_order = 1;
pub const memory_order_memory_order_acquire: memory_order = 2;
pub const memory_order_memory_order_release: memory_order = 3;
pub const memory_order_memory_order_acq_rel: memory_order = 4;
pub const memory_order_memory_order_seq_cst: memory_order = 5;
pub type memory_order = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn atomic_thread_fence(arg1: memory_order);
}
unsafe extern "C" {
    pub fn atomic_signal_fence(arg1: memory_order);
}
pub type atomic_bool = bool;
pub type atomic_char = ::std::os::raw::c_char;
pub type atomic_schar = ::std::os::raw::c_schar;
pub type atomic_uchar = ::std::os::raw::c_uchar;
pub type atomic_short = ::std::os::raw::c_short;
pub type atomic_ushort = ::std::os::raw::c_ushort;
pub type atomic_int = ::std::os::raw::c_int;
pub type atomic_uint = ::std::os::raw::c_uint;
pub type atomic_long = ::std::os::raw::c_long;
pub type atomic_ulong = ::std::os::raw::c_ulong;
pub type atomic_llong = ::std::os::raw::c_longlong;
pub type atomic_ullong = ::std::os::raw::c_ulonglong;
pub type atomic_char16_t = uint_least16_t;
pub type atomic_char32_t = uint_least32_t;
pub type atomic_wchar_t = wchar_t;
pub type atomic_int_least8_t = int_least8_t;
pub type atomic_uint_least8_t = uint_least8_t;
pub type atomic_int_least16_t = int_least16_t;
pub type atomic_uint_least16_t = uint_least16_t;
pub type atomic_int_least32_t = int_least32_t;
pub type atomic_uint_least32_t = uint_least32_t;
pub type atomic_int_least64_t = int_least64_t;
pub type atomic_uint_least64_t = uint_least64_t;
pub type atomic_int_fast8_t = int_fast8_t;
pub type atomic_uint_fast8_t = uint_fast8_t;
pub type atomic_int_fast16_t = int_fast16_t;
pub type atomic_uint_fast16_t = uint_fast16_t;
pub type atomic_int_fast32_t = int_fast32_t;
pub type atomic_uint_fast32_t = uint_fast32_t;
pub type atomic_int_fast64_t = int_fast64_t;
pub type atomic_uint_fast64_t = uint_fast64_t;
pub type atomic_intptr_t = isize;
pub type atomic_uintptr_t = usize;
pub type atomic_size_t = usize;
pub type atomic_ptrdiff_t = isize;
pub type atomic_intmax_t = intmax_t;
pub type atomic_uintmax_t = uintmax_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct atomic_flag {
    pub _Value: atomic_bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of atomic_flag"][::std::mem::size_of::<atomic_flag>() - 1usize];
    ["Alignment of atomic_flag"][::std::mem::align_of::<atomic_flag>() - 1usize];
    ["Offset of field: atomic_flag::_Value"][::std::mem::offset_of!(atomic_flag, _Value) - 0usize];
};
unsafe extern "C" {
    pub fn atomic_flag_test_and_set(arg1: *mut atomic_flag) -> bool;
}
unsafe extern "C" {
    pub fn atomic_flag_test_and_set_explicit(arg1: *mut atomic_flag, arg2: memory_order) -> bool;
}
unsafe extern "C" {
    pub fn atomic_flag_clear(arg1: *mut atomic_flag);
}
unsafe extern "C" {
    pub fn atomic_flag_clear_explicit(arg1: *mut atomic_flag, arg2: memory_order);
}
#[doc = " @brief Individual signal lane, aligned to prevent false sharing."]
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct splinter_signal_node {
    pub counter: atomic_uint_least64_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of splinter_signal_node"][::std::mem::size_of::<splinter_signal_node>() - 64usize];
    ["Alignment of splinter_signal_node"][::std::mem::align_of::<splinter_signal_node>() - 64usize];
    ["Offset of field: splinter_signal_node::counter"]
        [::std::mem::offset_of!(splinter_signal_node, counter) - 0usize];
};
#[doc = " @struct splinter_header\n @brief Defines the header structure for the shared memory region.\n\n This header contains metadata for the entire splinter store, including\n magic number for validation, version, and overall store configuration.\n\n NOTE: We add parse_failures/last_failure_epoch for diagnostics."]
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct splinter_header {
    #[doc = " @brief Magic number (SPLINTER_MAGIC) to verify integrity."]
    pub magic: u32,
    #[doc = " @brief Data layout version (SPLINTER_VER)."]
    pub version: u32,
    #[doc = " @brief Total number of available key-value slots."]
    pub slots: u32,
    #[doc = " @brief Maximum size for any single value."]
    pub max_val_sz: u32,
    #[doc = " @brief Global epoch, incremented on any write. Used for change detection."]
    pub epoch: atomic_uint_least64_t,
    #[doc = " @brief Core feature flags"]
    pub core_flags: atomic_uint_least8_t,
    #[doc = " @brief User-defined feature flags"]
    pub user_flags: atomic_uint_least8_t,
    #[doc = " @brief Track the next-available value region"]
    pub val_brk: atomic_uint_least32_t,
    #[doc = " @brief Running total size of the arena"]
    pub val_sz: u32,
    #[doc = " @brief Memory alignment (e.g  64)"]
    pub alignment: u32,
    pub parse_failures: atomic_uint_least64_t,
    pub last_failure_epoch: atomic_uint_least64_t,
    pub bloom_watches: [atomic_uint_least8_t; 64usize],
    pub __bindgen_padding_0: u64,
    pub signal_groups: [splinter_signal_node; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of splinter_header"][::std::mem::size_of::<splinter_header>() - 4224usize];
    ["Alignment of splinter_header"][::std::mem::align_of::<splinter_header>() - 64usize];
    ["Offset of field: splinter_header::magic"]
        [::std::mem::offset_of!(splinter_header, magic) - 0usize];
    ["Offset of field: splinter_header::version"]
        [::std::mem::offset_of!(splinter_header, version) - 4usize];
    ["Offset of field: splinter_header::slots"]
        [::std::mem::offset_of!(splinter_header, slots) - 8usize];
    ["Offset of field: splinter_header::max_val_sz"]
        [::std::mem::offset_of!(splinter_header, max_val_sz) - 12usize];
    ["Offset of field: splinter_header::epoch"]
        [::std::mem::offset_of!(splinter_header, epoch) - 16usize];
    ["Offset of field: splinter_header::core_flags"]
        [::std::mem::offset_of!(splinter_header, core_flags) - 24usize];
    ["Offset of field: splinter_header::user_flags"]
        [::std::mem::offset_of!(splinter_header, user_flags) - 25usize];
    ["Offset of field: splinter_header::val_brk"]
        [::std::mem::offset_of!(splinter_header, val_brk) - 28usize];
    ["Offset of field: splinter_header::val_sz"]
        [::std::mem::offset_of!(splinter_header, val_sz) - 32usize];
    ["Offset of field: splinter_header::alignment"]
        [::std::mem::offset_of!(splinter_header, alignment) - 36usize];
    ["Offset of field: splinter_header::parse_failures"]
        [::std::mem::offset_of!(splinter_header, parse_failures) - 40usize];
    ["Offset of field: splinter_header::last_failure_epoch"]
        [::std::mem::offset_of!(splinter_header, last_failure_epoch) - 48usize];
    ["Offset of field: splinter_header::bloom_watches"]
        [::std::mem::offset_of!(splinter_header, bloom_watches) - 56usize];
    ["Offset of field: splinter_header::signal_groups"]
        [::std::mem::offset_of!(splinter_header, signal_groups) - 128usize];
};
#[doc = " @struct splinter_slot\n @brief Defines a single key-value slot in the hash table.\n\n Each slot holds a key, its value's location and length, and metadata\n for concurrent access and change tracking.\n\n We changed val_len to atomic to avoid tearing on platforms where a plain\n 32-bit write could be observed partially by a reader."]
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct splinter_slot {
    #[doc = " @brief The FNV-1a hash of the key. 0 indicates an empty slot."]
    pub hash: atomic_uint_least64_t,
    #[doc = " @brief Per-slot epoch, incremented on write to this slot. Used for polling."]
    pub epoch: atomic_uint_least64_t,
    #[doc = " @brief Offset into the VALUES region where the value data is stored."]
    pub val_off: u32,
    #[doc = " @brief The actual length of the stored value data (atomic)."]
    pub val_len: atomic_uint_least32_t,
    #[doc = " @brief The type-naming flags for slot typing"]
    pub type_flag: atomic_uint_least8_t,
    #[doc = " @brief The user-defined flags for slot features"]
    pub user_flag: atomic_uint_least8_t,
    #[doc = " @brief Watcher signal group for multi-watching"]
    pub watcher_mask: atomic_uint_least64_t,
    #[doc = " @brief The time a slot was created (optional; must be set by the client)"]
    pub ctime: atomic_uint_least64_t,
    #[doc = " @brief The last time the slot was meaningfully accessed (optional; must be set by the client)"]
    pub atime: atomic_uint_least64_t,
    #[doc = " @brief The 64-bit Bloom filter / Label mask"]
    pub bloom: atomic_uint_least64_t,
    #[doc = " @brief The null-terminated key string."]
    pub key: [::std::os::raw::c_char; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of splinter_slot"][::std::mem::size_of::<splinter_slot>() - 128usize];
    ["Alignment of splinter_slot"][::std::mem::align_of::<splinter_slot>() - 64usize];
    ["Offset of field: splinter_slot::hash"][::std::mem::offset_of!(splinter_slot, hash) - 0usize];
    ["Offset of field: splinter_slot::epoch"]
        [::std::mem::offset_of!(splinter_slot, epoch) - 8usize];
    ["Offset of field: splinter_slot::val_off"]
        [::std::mem::offset_of!(splinter_slot, val_off) - 16usize];
    ["Offset of field: splinter_slot::val_len"]
        [::std::mem::offset_of!(splinter_slot, val_len) - 20usize];
    ["Offset of field: splinter_slot::type_flag"]
        [::std::mem::offset_of!(splinter_slot, type_flag) - 24usize];
    ["Offset of field: splinter_slot::user_flag"]
        [::std::mem::offset_of!(splinter_slot, user_flag) - 25usize];
    ["Offset of field: splinter_slot::watcher_mask"]
        [::std::mem::offset_of!(splinter_slot, watcher_mask) - 32usize];
    ["Offset of field: splinter_slot::ctime"]
        [::std::mem::offset_of!(splinter_slot, ctime) - 40usize];
    ["Offset of field: splinter_slot::atime"]
        [::std::mem::offset_of!(splinter_slot, atime) - 48usize];
    ["Offset of field: splinter_slot::bloom"]
        [::std::mem::offset_of!(splinter_slot, bloom) - 56usize];
    ["Offset of field: splinter_slot::key"][::std::mem::offset_of!(splinter_slot, key) - 64usize];
};
#[doc = " @struct splinter_header_snapshot\n @brief structure to hold splinter bus snapshots"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct splinter_header_snapshot {
    #[doc = " @brief Magic number (SPLINTER_MAGIC) to verify integrity."]
    pub magic: u32,
    #[doc = " @brief Data layout version (SPLINTER_VER)."]
    pub version: u32,
    #[doc = " @brief Total number of available key-value slots."]
    pub slots: u32,
    #[doc = " @brief Maximum size for any single value."]
    pub max_val_sz: u32,
    #[doc = " @brief Global epoch, incremented on any write. Used for change detection."]
    pub epoch: u64,
    #[doc = " @Brief holds the slot type flags"]
    pub core_flags: u8,
    #[doc = " @Brief holds the slot user flags"]
    pub user_flags: u8,
    pub parse_failures: u64,
    pub last_failure_epoch: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of splinter_header_snapshot"]
        [::std::mem::size_of::<splinter_header_snapshot>() - 48usize];
    ["Alignment of splinter_header_snapshot"]
        [::std::mem::align_of::<splinter_header_snapshot>() - 8usize];
    ["Offset of field: splinter_header_snapshot::magic"]
        [::std::mem::offset_of!(splinter_header_snapshot, magic) - 0usize];
    ["Offset of field: splinter_header_snapshot::version"]
        [::std::mem::offset_of!(splinter_header_snapshot, version) - 4usize];
    ["Offset of field: splinter_header_snapshot::slots"]
        [::std::mem::offset_of!(splinter_header_snapshot, slots) - 8usize];
    ["Offset of field: splinter_header_snapshot::max_val_sz"]
        [::std::mem::offset_of!(splinter_header_snapshot, max_val_sz) - 12usize];
    ["Offset of field: splinter_header_snapshot::epoch"]
        [::std::mem::offset_of!(splinter_header_snapshot, epoch) - 16usize];
    ["Offset of field: splinter_header_snapshot::core_flags"]
        [::std::mem::offset_of!(splinter_header_snapshot, core_flags) - 24usize];
    ["Offset of field: splinter_header_snapshot::user_flags"]
        [::std::mem::offset_of!(splinter_header_snapshot, user_flags) - 25usize];
    ["Offset of field: splinter_header_snapshot::parse_failures"]
        [::std::mem::offset_of!(splinter_header_snapshot, parse_failures) - 32usize];
    ["Offset of field: splinter_header_snapshot::last_failure_epoch"]
        [::std::mem::offset_of!(splinter_header_snapshot, last_failure_epoch) - 40usize];
};
#[doc = " @struct splinter_header_snapshot\n @brief structure to hold splinter bus snapshots"]
pub type splinter_header_snapshot_t = splinter_header_snapshot;
unsafe extern "C" {
    #[doc = " @brief Copy the current atomic Splinter header structure into a corresponding\n non-atomic client version.\n @param snapshot A splinter_header_snaphshot_t structure to receive the values.\n @return -1 on failure, 0 on success."]
    pub fn splinter_get_header_snapshot(
        snapshot: *mut splinter_header_snapshot_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @structure splinter_slot_snapshot\n @brief A structure to hold a snapshot of a single slot"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct splinter_slot_snapshot {
    #[doc = " @brief The FNV-1a hash of the key. 0 indicates an empty slot."]
    pub hash: u64,
    #[doc = " @brief Per-slot epoch, incremented on write to this slot. Used for polling."]
    pub epoch: u64,
    #[doc = " @brief Offset into the VALUES region where the value data is stored."]
    pub val_off: u32,
    #[doc = " @brief The actual length of the stored value data (atomic)."]
    pub val_len: u32,
    #[doc = " @brief The slot type flags"]
    pub type_flag: u8,
    #[doc = " @brief The slot user flags"]
    pub user_flag: u8,
    #[doc = " @brief Storage for creation time"]
    pub ctime: u64,
    #[doc = " @brief Storage for access time"]
    pub atime: u64,
    #[doc = " @brief The null-terminated key string."]
    pub key: [::std::os::raw::c_char; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of splinter_slot_snapshot"][::std::mem::size_of::<splinter_slot_snapshot>() - 112usize];
    ["Alignment of splinter_slot_snapshot"]
        [::std::mem::align_of::<splinter_slot_snapshot>() - 8usize];
    ["Offset of field: splinter_slot_snapshot::hash"]
        [::std::mem::offset_of!(splinter_slot_snapshot, hash) - 0usize];
    ["Offset of field: splinter_slot_snapshot::epoch"]
        [::std::mem::offset_of!(splinter_slot_snapshot, epoch) - 8usize];
    ["Offset of field: splinter_slot_snapshot::val_off"]
        [::std::mem::offset_of!(splinter_slot_snapshot, val_off) - 16usize];
    ["Offset of field: splinter_slot_snapshot::val_len"]
        [::std::mem::offset_of!(splinter_slot_snapshot, val_len) - 20usize];
    ["Offset of field: splinter_slot_snapshot::type_flag"]
        [::std::mem::offset_of!(splinter_slot_snapshot, type_flag) - 24usize];
    ["Offset of field: splinter_slot_snapshot::user_flag"]
        [::std::mem::offset_of!(splinter_slot_snapshot, user_flag) - 25usize];
    ["Offset of field: splinter_slot_snapshot::ctime"]
        [::std::mem::offset_of!(splinter_slot_snapshot, ctime) - 32usize];
    ["Offset of field: splinter_slot_snapshot::atime"]
        [::std::mem::offset_of!(splinter_slot_snapshot, atime) - 40usize];
    ["Offset of field: splinter_slot_snapshot::key"]
        [::std::mem::offset_of!(splinter_slot_snapshot, key) - 48usize];
};
#[doc = " @structure splinter_slot_snapshot\n @brief A structure to hold a snapshot of a single slot"]
pub type splinter_slot_snapshot_t = splinter_slot_snapshot;
pub const splinter_integer_op_t_SPL_OP_AND: splinter_integer_op_t = 0;
pub const splinter_integer_op_t_SPL_OP_OR: splinter_integer_op_t = 1;
pub const splinter_integer_op_t_SPL_OP_XOR: splinter_integer_op_t = 2;
pub const splinter_integer_op_t_SPL_OP_NOT: splinter_integer_op_t = 3;
pub const splinter_integer_op_t_SPL_OP_INC: splinter_integer_op_t = 4;
pub const splinter_integer_op_t_SPL_OP_DEC: splinter_integer_op_t = 5;
#[doc = " @brief for atomic integer operations"]
pub type splinter_integer_op_t = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " @brief Copy the current atomic Splinter slot header to a corresponding client\n structure.\n @param snapshot A splinter_slot_snaphshot_t structure to receive the values.\n @return -1 on failure, 0 on success."]
    pub fn splinter_get_slot_snapshot(
        key: *const ::std::os::raw::c_char,
        snapshot: *mut splinter_slot_snapshot_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Creates and initializes a new splinter store.\n @param name_or_path The name of the shared memory object or path to the file.\n @param slots The total number of key-value slots to allocate.\n @param max_value_sz The maximum size in bytes for any single value.\n @return 0 on success, -1 on failure (e.g., store already exists)."]
    pub fn splinter_create(
        name_or_path: *const ::std::os::raw::c_char,
        slots: usize,
        max_value_sz: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Opens an existing splinter store.\n @param name_or_path The name of the shared memory object or path to the file.\n @return 0 on success, -1 on failure (e.g., store does not exist)."]
    pub fn splinter_open(name_or_path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Opens an existing splinter store, or creates it if it does not exist.\n @param name_or_path The name of the shared memory object or path to the file.\n @param slots The total number of key-value slots if creating.\n @param max_value_sz The maximum value size in bytes if creating.\n @return 0 on success, -1 on failure."]
    pub fn splinter_open_or_create(
        name_or_path: *const ::std::os::raw::c_char,
        slots: usize,
        max_value_sz: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Creates a new splinter store, or opens it if it already exists.\n @param name_or_path The name of the shared memory object or path to the file.\n @param slots The total number of key-value slots if creating.\n @param max_value_sz The maximum value size in bytes if creating.\n @return 0 on success, -1 on failure."]
    pub fn splinter_create_or_open(
        name_or_path: *const ::std::os::raw::c_char,
        slots: usize,
        max_value_sz: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Closes the splinter store and unmaps the shared memory region."]
    pub fn splinter_close();
}
unsafe extern "C" {
    #[doc = " @brief Set the value of the auto_scrub flag on the current bus."]
    pub fn splinter_set_av(mode: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Engage hybrid auto scrub\n @return int (sets errno)"]
    pub fn splinter_set_hybrid_av() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Check hybrid status of auto scrub engagement\n @return int"]
    pub fn splinter_get_hybrid_av() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Check each key, and zero out memory past the value length to the\n allocated slot length (essentially sweep out any old data). Designed to be\n used as part of backfill runs when I/O slamming has stopped."]
    pub fn splinter_purge();
}
unsafe extern "C" {
    #[doc = " @brief Get the value of the auto_scrub flag on the current bus as integer."]
    pub fn splinter_get_av() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Sets or updates a key-value pair in the store.\n @param key The null-terminated key string.\n @param val Pointer to the value data.\n @param len The length of the value data. Must not exceed `max_val_sz`.\n @return 0 on success, -1 on failure (e.g., store is full)."]
    pub fn splinter_set(
        key: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief \"unsets\" a key.\n This function does one atomic operation to zero the slot hash, which marks the\n slot available for write. It then zeroes out the used key and value regions,\n and resets the slot.\n\n @param key The null-terminated key string.\n @return length of value deleted, -1 if key not found, - 2 if null key/store"]
    pub fn splinter_unset(key: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Retrieves the value associated with a key.\n @param key The null-terminated key string.\n @param buf The buffer to copy the value data into. Can be NULL to query size.\n @param buf_sz The size of the provided buffer.\n @param out_sz Pointer to a size_t to store the value's actual length. Can be NULL.\n @return 0 on success, -1 on failure. If buf_sz is too small, sets errno to EMSGSIZE."]
    pub fn splinter_get(
        key: *const ::std::os::raw::c_char,
        buf: *mut ::std::os::raw::c_void,
        buf_sz: usize,
        out_sz: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Lists all keys currently in the store.\n @param out_keys An array of `char*` to be filled with pointers to the keys.\n @param max_keys The maximum number of keys to write to `out_keys`.\n @param out_count Pointer to a size_t to store the number of keys found.\n @return 0 on success, -1 on failure."]
    pub fn splinter_list(
        out_keys: *mut *mut ::std::os::raw::c_char,
        max_keys: usize,
        out_count: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Waits for a key's value to be changed.\n @param key The key to monitor for changes.\n @param timeout_ms The maximum time to wait in milliseconds.\n @return 0 if the value changed, -1 on timeout or if the key doesn't exist."]
    pub fn splinter_poll(
        key: *const ::std::os::raw::c_char,
        timeout_ms: u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Set a bus configuration value\n @param hdr: a splinter  bus header structure\n @param mask: bitmask to apply"]
    pub fn splinter_config_set(hdr: *mut splinter_header, mask: u8);
}
unsafe extern "C" {
    #[doc = " @brief Clear a bus configuration value\n @param hdr: a splinter  bus header structure\n @param mask: bitmask to clear"]
    pub fn splinter_config_clear(hdr: *mut splinter_header, mask: u8);
}
unsafe extern "C" {
    #[doc = " @brief Test a bus configuration value\n @param hdr: a splinter  bus header structure\n @param mask: bitmask to test"]
    pub fn splinter_config_test(hdr: *mut splinter_header, mask: u8) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Snapshot a bus configuration\n @param hdr: a splinter  bus header structure"]
    pub fn splinter_config_snapshot(hdr: *mut splinter_header) -> u8;
}
unsafe extern "C" {
    #[doc = " @brief Set a user slot flag\n @param slot Splinter slot structure\n @param mask bitmask to set"]
    pub fn splinter_slot_usr_set(slot: *mut splinter_slot, mask: u16);
}
unsafe extern "C" {
    #[doc = " @brief Clear a user slot flag\n @param slot Splinter slot structure\n @param mask bitmask to clear"]
    pub fn splinter_slot_usr_clear(slot: *mut splinter_slot, mask: u16);
}
unsafe extern "C" {
    #[doc = " @brief Test a user slot flag\n @param slot Splinter slot structure\n @param mask bitmask to test"]
    pub fn splinter_slot_usr_test(slot: *mut splinter_slot, mask: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Get a user slot flag snapshot\n @param slot Splinter slot structure"]
    pub fn splinter_slot_usr_snapshot(slot: *mut splinter_slot) -> u16;
}
unsafe extern "C" {
    #[doc = " @brief Name (declare intent to) a type fo a slot\n @param key Name of the key to change\n @param mask Splinter type bitmask to apply (e.g SPL_SLOT_TYPE_BIGUINT)\n @return -1 or on error (sets errno), 0 on success"]
    pub fn splinter_set_named_type(
        key: *const ::std::os::raw::c_char,
        mask: u16,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Update a slot's ctime / atime\n @param key Name of the key to change\n @param mode (SPL_TIME_CTIME or SPL_TIME_ATIME)\n @param epoch client-supplied timestamp\n @param offset value to subtract from epoch due to update-after-write\n @return -1/-2 or on error (sets errno), 0 on success"]
    pub fn splinter_set_slot_time(
        key: *const ::std::os::raw::c_char,
        mode: ::std::os::raw::c_ushort,
        epoch: u64,
        offset: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Bitwise & arithmetic ops on keys named as big unsigned\n @param key Name of the key  to operate on\n @param op Operation you want to do\n @param mask What you want to do it with\n @return 0 on success, -1 / -2 on internal / caller errors respectively"]
    pub fn splinter_integer_op(
        key: *const ::std::os::raw::c_char,
        op: splinter_integer_op_t,
        mask: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Get a direct pointer to a value in shared memory.\n @warning Unsafe: The data at this pointer can change or be zeroed if a\n writer modifies the slot. Use splinter_get_epoch to verify consistency.\n @param key The key to look up.\n @param out_sz Pointer to receive the actual length of the value.\n @param out_epoch Pointer to receive the epoch at the time of lookup.\n @return A const pointer to the data in SHM, or NULL if not found."]
    pub fn splinter_get_raw_ptr(
        key: *const ::std::os::raw::c_char,
        out_sz: *mut usize,
        out_epoch: *mut u64,
    ) -> *const ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " @brief Get the current epoch of a specific slot.\n @return The 64-bit epoch, or 0 if key not found."]
    pub fn splinter_get_epoch(key: *const ::std::os::raw::c_char) -> u64;
}
unsafe extern "C" {
    #[doc = " @brief Atomically apply a label mask to a slot's Bloom filter.\n @return 0 on success, -1 if key not found."]
    pub fn splinter_set_label(
        key: *const ::std::os::raw::c_char,
        mask: u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Client-side helper to write multiple orders of a key.\n * Since we've backed out library-side linking, this helper manages\n the naming convention for the caller."]
    pub fn splinter_client_set_tandem(
        base_key: *const ::std::os::raw::c_char,
        vals: *mut *const ::std::os::raw::c_void,
        lens: *const usize,
        orders: u8,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Client-side helper to delete a key and its known orders."]
    pub fn splinter_client_unset_tandem(base_key: *const ::std::os::raw::c_char, orders: u8);
}
unsafe extern "C" {
    #[doc = " @brief Registers interest in a key's group signal."]
    pub fn splinter_watch_register(
        key: *const ::std::os::raw::c_char,
        group_id: u8,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Unregisters interest in a key's group signal."]
    pub fn splinter_watch_unregister(
        key: *const ::std::os::raw::c_char,
        group_id: u8,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Maps a Bloom label (bitmask) to a signal group."]
    pub fn splinter_watch_label_register(bloom_mask: u64, group_id: u8) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @brief Internal helper to pulse the Signal Arena for a slot."]
    pub fn splinter_pulse_watchers(slot: *mut splinter_slot);
}
unsafe extern "C" {
    #[doc = " @brief Safely retrieve the current pulse count for a signal group. Good for debugging.\n @param group_id The signal group (0-63).\n @return The 64-bit pulse count, or 0 if invalid."]
    pub fn splinter_get_signal_count(group_id: u8) -> u64;
}
