hero:
  title: Share State &amp; KV Between Workflows In-Memory, Lock-Free!
  href: /blog/example-post/
  cta: "View Some Practical Examples!"
  slogan: Splinter is a tiny, lock-free atomic KV store and system message bus written in C. It features static geometry, pub/sub, integer manipulation, dimensional vector storage, tagging, LUA scripting and loadable modules. Splinter lets you share address space between modern workflows safely, without opinions, or just cache versioned copy for semantic retrieval. It also features a robust CLI that brings new possibilities to shell scripting. 

goals:
  - title: Atomic IPC Across Runtimes
    body: |
      Share and poll raw binary or encoded and serialized data between processes 
      written in different programming languages <a href="#">without the overhead 
      of locks or sockets</a>. 
    href: "#"
    cta: See IPC &amp; FFI Examples
  - title: Scripting & Triggers With Lua
    body: |
      Create scripts with store values as tables, or stored procedures clients run
      before or after certain types of operations. Lua is also available interactively
      in the CLI.
    href: "#"
    cta: See Splinter's Lua Integration
  - title: "&quot;MRSW/MRMW&quot; Semantics"
    body: |
      MRSW is guaranteed globally. Disjointed key MRMW is guaranteed provided active
      writers do not exceed total allocated slots. Helmets not required, thanks to
      fixed-geometry and atomic sequence locks. 
    href: "#"
    cta: Seqlock Benefits & Tradeoffs

aspirations:
  - title: Dimensional Vector Storage
    body: |
      Named text keys have space for 768-dimension vectors; Splinter allows you to refresh 
      those vectors "sidecar" style based on epoch, similar to open source vector databases. 
      Search is left as an exercise for the caller.  
    href: "#"
    cta: See Semantic Caching Use Cases
  - title: Atomic Integer & Bitwise Ops
    body: |
      Keys that have been named as integers can be operated on atomically, in-place, 
      using common bitwise operations (`and`, `or`, `not`, `xor`), as well as `incr`,
      `decr` and conditional ops.
    href: "#"
    cta: Explore Integer Operations
  - title: Intuitive, Simplified Pub/Sub
    body: |
      Watch for changes at the per-slot, or global store level simply by observing atomic
      epoch counters. Splinter includes a simple timeout-based API to do this that lends
      very well to Linux <code>epoll()</code> use.
    href: "#"
    cta: Seqlock Benefits & Tradeoffs

use_case:
  title: "Splinter storage is unopinionated by design; logic only happens in loadable modules and / or Lua scripts."
  body: |
      Splinter hyper-focuses on <em>storing</em> data with 100% fidelity as fast as possible. 
      Things like eviction strategy and policy, embedding refreshing, cosine calculation or 
      indexing are functions that databases undertake, so splinter partitions this kind of 
      task to dynamically loadable modules called <em>shards</em> Shards have access to the 
      internal API and scripting as well as the ability to register callbacks around I/O events 
      necessary for them to function.
      <br /><br />
      With tight Lua integration, Splinter lets you access and operate on your stored contents
      just like any other Lua table, with access to global state and most of the C API exposed
      as functions. Operating on the global store table in Lua reflects atomically in the store.
      <br /><br />
  href: "#"
  cta: Check Out Loadable Modules & Scripting!
